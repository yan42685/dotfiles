; [url "https://"]
;     insteadOf = git://

# 专为github设置的代理
[http "https://github.com"]
    proxy = socks5://127.0.0.1:6543
[https "https://github.com"]
    proxy = socks5://127.0.0.1:6543
[user]
	name = alex
	email = 419725794@qq.com
[core]
    editor = nvim
    quotepath = false  # 解决git ls不显示中文的问题

[commit]
    # 设置 commit 模板文件路径
    template = ~/.config/git/.gitmessage

[pager]
    # 查看log，NOTE: 依赖Flog.vim插件
    ; log = editor --git-log
    log = false
	branch = false
    tag = false
    reflog = false

# difftool用editor(nvr) 有bug， 还是vimdiff3 好
[diff]
    tool = vimdiff3
[difftool]
    prompt = false
    trustExitCode = true
[difftool "vimdiff3"]
    path = nvim

[merge]
    tool = vim_mergetool
    conflictStyle = diff3
[mergetool]
    prompt = false
    trustExitCode = true
    # 这样在解决冲突后就不会保留.orig文件了
	keepBackup = false
[mergetool "vim_mergetool"]
    # floaterm用nvr mergetool 有bug 还是nvim好, 然后<Alt-o>放大floaterm
    cmd = nvim -f -c "MergetoolStart" "$MERGED" "$BASE" "$LOCAL" "$REMOTE"

[pull]
    # pull时用rebase="interactive"替代merge
    ; rebase = "interactive"
    rebase = true

[push]
    # push自动带上tags
	followTags = true

[credential]
    # 缓存HTTP/HTTPS方式输入的用户名密码时间, 设置为
    # 时间单位为秒 此处为大于100年
    helper = cache --timeout=3600000000

[alias]
    # remerge 重新merge
    rem = checkout --conflict=diff3
    # 很多alias来自 https://github.com/GitAlias/gitalias/blob/master/gitalias.txt
    ### add ###
    ad = add
    # add all
    aa = add -A
    # add by patch - looks at each change, and asks if we want to put it in the repo.
    ap = add --patch
    # add just the files that are updated.
    au = add --update

    ### branch
    b = branch
    # 显示所有分支，包括远程
    ba = branch -a
    # 显示最后一次提交
    bv = branch -v
    bav = branch -v -a
    bmg = branch --merged
    bnmg = branch --no-merged

    bd = branch -d
    # 强制删除未merge的分支
    bD = branch -D
    # 可在--list 后面写搜索版本号, 比如git tgs '*1' (如果不加引号要用\*转义) 也可不写搜索内容
    tags = tag -n1 --list
    stashes = stash list

    ### commit ###
    # commit with a message
    c = commit -a
    # 将新的修改全部应用到上次commit里
    cmd = "!git add --update && git commit --amend --no-edit"
    cmde = "!git add --update && git commit --amend"
    ca = commit -a --message
    # commit and push
    cap = "!f() { git commit --all -m \"$@\" && git push; }; f"

    ### checkout ###
    # checkout - update the working tree to match a branch or paths. [same as "o" for "out"]
    co = checkout
    cob = checkout -b
    co-rs = checkout --

    ### cherry-pick ###
    # cherry-pick - apply the changes introduced by some existing commits; useful for moving small chunks of code between branches.
    cp = cherry-pick
    # cherry-pick - abort the picking process
    cpa = cherry-pick --abort
    # cherry-pick - continue the picking process
    cpc = cherry-pick --continue
    # cherry-pick without making a commit, and when when recording the commit, append a line that says "(cherry picked from commit ...)"
    cp-nx = cherry-pick --no-commit -x

    ### diff ###
    dt = difftool
    dt-staged = difftool --staged
    # diff - show changes not yet staged
    dc = diff --cached
    # diff - show changes about to be commited
    ds = diff --staged
    # diff - show changes but by word, not line
    dw = diff --word-diff
    # diff deep - show changes with our preferred options. Also aliased as `diff-deep`.
    dd = diff --check --dirstat --find-copies --find-renames --histogram --color

    ### grep ###
    # grep group - search with our preferred options. Also aliased as `grep-group`.
    gr = grep --break --heading --line-number --color

    ### log ###
    # NOTE: log 加了--graph 会让使用nvim 作为log的 pager时出bug
    # log with a text-based graphical representation of the commit history.
    ; lg = log --graph
    # log like - we like this summarization our key performance indicators. Also aliased as `log-like`.
    lg = log -10 --graph --topo-order --date=short --abbrev-commit --decorate --all --boundary --pretty=format:'%Cgreen%ad %Cred%h%Creset -%C(yellow)%d%Creset %s %Cblue[%cn]%Creset %Cblue%G?%Creset'
    ll = "!editor --git-log"
    # log like long  - we like this summarization our key performance indicators. Also aliased as `log-like-long`.
    lll = log --graph --topo-order --date=iso8601-strict --no-abbrev-commit --abbrev=40 --decorate --all --boundary --pretty=format:'%Cgreen%ad %Cred%h%Creset -%C(yellow)%d%Creset %s %Cblue[%cn <%ce>]%Creset %Cblue%G?%Creset'

    ## ls-files ##
    # ls-files - show information about files in the index and the working tree; like Unix "ls" command.
    ls = ls-files
    # ls-ignored -  list files that git has ignored.
    ls-ignored = ls-files --others --i --exclude-standard

    ### merge ###
    ; # merge but without autocommit, and with a commit even if the merge resolved as a fast-forward.
    ; mg = merge --no-commit --no-ff
    # merge but without autocommit, and with a commit 除非这个是同一路径上可以快进(faster-forward)的merge
    ; mg = merge --no-commit
    mg = merge
    mt = mergetool
    # merge并删除被merge的分支
    mgd = "!git merge $1 && git branch -d $1; #"
    ; mgs = merge --squash
    ; merge squash 默认删除之前的分支，常用于开发feature分支
    mgs = "!git merge --squash $1 && git commit -a; #"

    ### rebase ###
    rb = rebase
    rba = rebase --abort
    rbc = "!git add --update && git rebase --continue"
    rbi = rebase -i

    ### reflog ###
    # 恢复一个删除的分支用 checkout -b <branch> <SHA>
    ref = reflog --no-abbrev


    ### remote ###
    # 删除远程分支origin (origin可以换成别的)
    remote-delete-branch = push origin --delete
    # remote - manage set of tracked repositories [same as "r"].
    rr = remote
    # remote show - gives some information about the remote <name>.
    rrs = remote show

    ### revert ###
    # revert - undo the changes from some existing commits
    rv = revert
    # revert without autocommit; useful when you're reverting more than one commits' effect to your index in a row.
    rvnc = revert --no-commit

    ### show-branch ###
    # show-branch - print a list of branches and their commits.
    sb = show-branch

    ### status ###
    # status with short format instead of full details
    s = status --short --branch
    # status with short format and showing branch and tracking info.
    ; sb = status --short --branch

    ### command ###
    # Ignore all untracked files by appending them to .gitignore:
    ignore-untracked = "!git status | grep -P \"^\\t\" | grep -vF .gitignore | sed \"s/^\\t//\" >> .gitignore"

    uncommit = reset --soft HEAD~1
    uncommit-h = reset --hard HEAD~1
    unadd = reset HEAD
    unstage = reset HEAD
    # Discard changes in a (list of) file(s) in working tree
    discard = checkout --

    # Expunge a file everywhere; this command is typically for a serious problem,
    # such as accidentally committing a file of sensitive data, such as passwords.
    # After you use command, you will likely need to force push everything.
    # See https://help.github.com/articles/removing-sensitive-data-from-a-repository/
    expunge = "!f() { git filter-branch --force --index-filter \"git rm --cached --ignore-unmatch $1\" --prune-empty --tag-name-filter cat -- --all }; f"

    # Delete all branches that have already been merged into the master branch.
    master-branch-clean = "!git master-branch-clean-local"
    # Delete all local branches that have been merged into the local master branch.
    master-branch-clean-local = "!git checkout master && git branch --merged | xargs git branch --delete"
    # Delete all remote branches that have been merged into the remote master branch.
    master-branch-clean-remote = "!git branch --remotes --merged origin/master | sed 's# *origin/##' | grep -v '^master$' xargs -I% git push origin :% 2>&1 | grep --colour=never 'deleted'"
    # Get the current branch name (not so useful in itself, but used in other aliases)
    branch-name = "!git rev-parse --abbrev-ref HEAD"
    # Push the current branch to the remote "origin", and set it to track
    # the upstream branch
    publish = "!git push -u origin $(git branch-name)"
    # Delete the remote version of the current branch
    unpublish = "!git push origin :"
    # Fire up your difftool (e.g. Kaleidescope) with all the changes that
    # are on the current branch.
    code-review = "!git difftool origin/$(git branch-name)..."

    # Delete a branch name, then create the same branch name based on master -
    # useful if you have, for example, a development branch and master branch
    # and they go out of sync, and you want to nuke the development branch.
    #
    # Calls the `publish` and `unpublish` aliases.
    #
    recreate = "!f() { [[ -n $@ ]] && git checkout \"$@\" && git unpublish && git checkout master && git branch -D \"$@\" && git checkout -b \"$@\" && git publish; }; f"

    ahead-of-origin = "!git log --oneline origin/$(git branch-name)..HEAD"  # Show commits that haven't made it to remote master yet.
    ps = push
    ft = fetch
    pl = pull
    df-staged = diff --staged --color
    df-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh diff
    ad-u = reset HEAD --
    ad-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh add
    co-rs-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh restore
    logs = log --oneline --decorate --graph --pretty=format:\"(%h)  %an, %ar: %s\"
    logs-all = log --oneline --decorate --graph --all --pretty=format:\"(%h)  %an, %ar: %s\"
    log-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh log
    ig-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh ignore
    ; edit = !nvim `git ls-files -m --other --exclude-standard` -p
    rg = !rg $(git rev-parse --show-toplevel) --column --smart-case -e
    rg-ls = !rg $(git rev-parse --show-toplevel) --files
    rg-all = !rg $(git rev-parse --show-toplevel) --column --smart-case --no-ignore --hidden -g '!.git' -e
    rg-all-ls = !rg $(git rev-parse --show-toplevel) --no-ignore --hidden -g '!.git' --files
