; FIXME: 在gitconfig里写的bash注意事项
; NOTE: 1. alias不区分大小写
;       2. 和git-extras一起使用效果更佳
; {{{  在gitconfig里写的bash注意事项
;           1. 应该用[ ] 而不是[[ ]], 不然会报错
;           2. 不能写#注释
;           3. 语句后面要写分号;
;           4. if [ -n  \"$abc\" ]; then 用-n或-z 判断字符串不为空/为空需要用双引号，不能不加引号或者是单引号
;           5. 双引号内一个 \ 就可以连接多行单命令语句了，用\\会转义空格的
;}}}
;基础设置 {{{
# 专为github设置的代理
[http "https://github.com"]
    proxy = socks5://127.0.0.1:6543
[https "https://github.com"]
    proxy = socks5://127.0.0.1:6543
[user]
    name = alex
    email = 419725794@qq.com
[core]
    editor = nvim
    quotepath = false  # 解决git ls不显示中文的问题

[commit]
    # 设置 commit 模板文件路径
    template = ~/.config/git/.gitmessage
[pager]
    # 以下命令不使用$PAGER浏览
    log = false
    branch = false
    tag = false
    reflog = false
    diff = false
    shortlog = false
    grep = false

# difftool用editor(nvr) 有bug， 还是nvim 好
[diff]
    tool = vimdiff3
[difftool]
    prompt = false
    trustExitCode = true
[difftool "vimdiff3"]
    path = nvim

[merge]
    tool = vim_mergetool
    conflictStyle = diff3
[mergetool]
    prompt = false
    trustExitCode = true
    # 这样在解决冲突后就不会保留.orig文件了
    keepBackup = false
[mergetool "vim_mergetool"]
    # floaterm用nvr mergetool 有bug 还是nvim好, 然后<Alt-o>放大floaterm
    cmd = nvim -f -c "MergetoolStart" "$MERGED" "$BASE" "$LOCAL" "$REMOTE"

[rebase]
    # 在rebase -i 里自动将 之前commit --fixup A 产生的commit 放在 A 之后
	autosquash = true
	autoStash = true

[fetch]
    # fetch自动prune
	prune = true
[pull]
    # pull时用rebase="interactive"替代merge
    ; rebase = "interactive"
    rebase = true

[push]
    # push自动带上tags
    followTags = true

[credential]
    # 缓存HTTP/HTTPS方式输入的用户名密码时间, 设置为
    # 时间单位为秒 此处为大于100年
    helper = cache --timeout=3600000000

# 用于 topic 工作流的自定义变量，定义主要用于向远程仓库推送的分支
[gitalias "topic.base.branch"]
	name = master

; }}}

[alias]    # 很多alias来自 https://github.com/GitAlias/gitalias/blob/master/gitalias.txt
; NOTE: 不要取名alias为 sync, cp 避免和git-extras冲突

; {{{ ### work flow ###

; {{{ ======== topic 工作流 =========
;   NOTE: 这套工作流正常应用的前提是
;                   1. 只有一个远程仓库且命名为origin
;                   2. 本地分支和远程分支名字相同
;
    ; 参考 https://github.com/GitAlias/gitalias/blob/master/gitalias.txt#L1217
    set-global-base-branch = config --global gitalias.topic.base.branch.name
    set-local-base-branch = config --local gitalias.topic.base.branch.name
    ; global base-branch 默认是master， 这里设置local base-branch
    set-bb = "!git set-local-base-branch"
    bb = "!git base-branch"

; {{{ topic-start-remote 介绍
    #
    # Example:
    #     git topic-start-remote feat/foo
    #     git topic-start-remote hotfix/bar
    #
    # We use this alias to begin work on a new feature,
    # new task, new fix, new refactor, new optimization, etc.
    #
    # Many teams share branches before they are fully ready, to help
    # the team provide feedback on the work-in-progress, and also to
    # run any automatic tests to verify the branch runs successfully.
    ##
; }}}
; {{{ topic-start-remote 开始一个topic分支并推送到remote
    topic-start-remote = "!f(){ \
        topic_branch=$1; \
        base_branch=$(git base-branch); \
        current_branch=$(git current-branch); \
        working_dir_dirty=$(git diff --stat | head -n -1); \
        if [ $current_branch != $base_branch ]; then \
            if [ -n \"$working_dir_dirty\" ]; then \
                git save \"Autosave on topic-start-remote: $topic_branch\"; \
            fi; \
            git checkout $base_branch; \
        fi; \
        git pull && git checkout -b $topic_branch $base_branch && git push -u origin $1; \
        };f"

; }}}
; {{{ topic-start-local 只在本地开启一个topic
    topic-start-local = "!f(){ \
        topic_branch=$1; \
        base_branch=$(git base-branch); \
        current_branch=$(git current-branch); \
        working_dir_dirty=$(git diff --stat | head -n -1); \
        if [ -n \"$working_dir_dirty\" ]; then \
            git save \"Autosave on topic-start-local: $topic_branch\"; \
        fi; \
        git checkout -b $topic_branch $base_branch; \
        };f"
; }}}
    tstr = "!git topic-start-remote"
    tst = "!git topic-start-local"

; {{{  topic-merge 通过merge --no-ff 方式合并topic 并且自动删除topic分支
;   merge后立刻删除分支就好，因为有merge历史记录，可以随时找回feature分支
    topic-merge = "!f() { \
        topic_branch=${1:-$(git current-branch)}; \
        base_branch=$(git base-branch); \
        current_branch=$(git current-branch); \
        working_dir_dirty=$(git diff --stat | head -n -1); \
        if [ $topic_branch = $base_branch ] || [ $topic_branch = master ]; then \
            printf \"You are asking to do git topic-stop,\n\"; \
            printf \"but you can't merge master or base branch: $base_branch.\n\"; \
            printf \"Please ask to merge valid topic branch.\n\"; \
        else \
            if [ -n \"$working_dir_dirty\" ]; then \
                git save \"Autosave on topic-merge: $topic_branch\"; \
            fi; \
            if [ $current_branch != $base_branch ]; then \
                git checkout $base_branch; \
            fi; \
            git pull && git merge --no-ff $topic_branch && git push && git topic-stop $topic_branch; \
        fi; \
        };f"
; }}}
    tmg = "!git topic-merge"

; {{{ topic-stop 删除远程(如果存在)和本地的topic分支
    topic-stop = "!f(){ \
        topic_branch=${1:-$(git current-branch)}; \
        base_branch=$(git base-branch); \
        current_branch=$(git current-branch); \
        existed_in_remote=$(git ls-remote --heads origin $current_branch | head -n -1); \
        working_dir_dirty=$(git diff --stat | head -n -1); \
        if [ $topic_branch = $base_branch ] || [ $topic_branch = master ]; then \
            printf \"You are asking to do git topic-stop,\n\"; \
            printf \"but you can't stop master or base branch: $base_branch.\n\"; \
            printf \"Please ask to stop valid topic branch.\n\"; \
        else \
            if [ -n \"$working_dir_dirty\" ]; then \
                git save \"Autosave on topic-stop: $topic_branch\"; \
            fi; \
            if [ $current_branch != $topic_branch ]; then \
                git checkout $topic_branch; \
            fi; \
            if [ -n \"$existed_in_remote\" ]; then \
                git pull origin $current_branch && git push origin $current_branch && git checkout $base_branch && git branch --delete $topic_branch \
                                                && git push origin --delete $topic_branch && git remote-prune-all; \
            fi; \
            git checkout $base_branch && git branch --delete $topic_branch; \
        fi; \
        };f"
; }}}
    tsp = "!git topic-stop"

    # 查看自分叉以来的diff
    topic-diff = "!git diff $(git base-branch)...$(git current-branch)"
    tdf = "!git topic-diff"
    # 不输入条数就是10个, 圆圈表示公共祖先分支
    topic-log = "!f() { \
        git log -${1:-10} $(git base-branch)...$(git current-branch) --graph --topo-order --date=short --abbrev-commit --decorate --boundary \
                            --pretty=format:'%Cgreen%ad %Cred%h%Creset -%C(yellow)%d%Creset %s %Cblue[%cn]%Creset %Cblue%G?%Creset'; \
    }; f"
    tlg = "!git topic-log"

; {{{ === 废弃 ===
; {{{ topic-rebase 通过rebase方式合并topic
    ; topic-rebase = "!f() { \
    ;     topic_branch=${1:-$(git current-branch)}; \
    ;     base_branch=$(git base-branch); \
    ;     current_branch=$(git current-branch); \
    ;     working_dir_dirty=$(git diff --stat | head -n -1); \
    ;     if [ $topic_branch = $base_branch ] || [ $topic_branch = master ]; then \
    ;     printf \"You are asking to do git topic-stop,\n\"; \
    ;     printf \"but you can't merge master or base branch: $base_branch.\n\"; \
    ;     printf \"Please ask to merge valid topic branch.\n\"; \
    ;     else \
    ;     if [ -n \"$working_dir_dirty\" ]; then \
    ;     git save \"Autosave on topic-rebase: $topic_branch\"; \
    ;     fi; \
    ;     if [ $current_branch != $base_branch ]; then \
    ;     git checkout $base_branch; \
    ;     fi; \
    ;     git pull && git checkout $topic_branch && git rebase $base_branch && git checkout $base_branch && git merge $topic_branch && git push && git topic-stop $topic_branch; \
    ;     fi; \
    ;     };f"
    ;
    ; trb = "!git topic-rebase"
; }}}
; }}}
; }}}
;
    ; 编辑和暂存有冲突的文件
    ; NOTE: 工作流:
    ;             $ git edit-unmerged
    ;                 ... edit ...
    ;                 ... test ...
    ;             $ git add-unmerged
    ;             $ git commit  # or git rebase --continue or whatever
    edit-unmerged = "!f() { git diff --name-status --diff-filter=U | cut -f2 ; }; ${EDITOR:-vi} `f`"
    add-unmerged = "!f() { git diff --name-status --diff-filter=U | cut -f2 ; }; git add `f`"

    # 预存提交信息
    todo = "!${EDITOR:-vi} $(git rev-parse --git-dir)/.template"
    # 用预存在文件里的信息提交
    cm = "!git commit -F $(git rev-parse --git-dir)/.template"

; }}}
; {{{ ### git-extras 常用命令备注 ###
;
;   ==== 查看信息 ====
;   git standup 查看某个人最近的提交   eg:  git standup -a John -d 7 也可不带参数查看自己
;   git show-tree  显示所有分支的详情，只显示每个分支最近一次提交
;   git contrib <username> 显示一个用户最近的提交
;   git summary --line 每个人代码行数及占比信息
;
;   git repl 连续输入命令不用输入git
;   git commits-since last week/ last month/ yesterday   默认是last week
;   git fork <username>/<repo>  从github fork项目并clone，设置origin
;   git release <tag>  新增Release commit (修改ChangeLog) 打tag并推送  (也会执行.git/hooks/pre-release.sh 和 .git/hooks/post-release.sh)
;   git ignore 查看或添加ignore    eg: git ignore "*.o" "*.log"
    ignore-io-serach = "!git ignore-io --search | fzf"
    ignore-io-append = "!git ignore-io --append"
    ignore-io-replace = "!git ignore-io --replace"  替换成另一种
;   git delete-tag  删除本地和远程tag         eg: git delete-tag 0.0.1
;
;
; }}}
; {{{ ### add ###

    a = add
    # add all
    aa = add -A
    # add by patch - looks at each change, and asks if we want to put it in the repo.
    ap = add --patch
    # add just the files that are updated.
    au = add --update

; }}}
; {{{ ### branch ###

    b = branch
    # 显示分支列表并 untrack 被删除的remote分支
    bl = "!git branch -av; git remote-prune-all &"
    blf = "!git branch --all | fzf"

    bm = branch --merged
    bnm = branch --no-merged
    bd = branch --delete
    bdf = branch -D
    # 可在--list 后面写搜索版本号, 比如git tgs '*1' (如果不加引号要用\*转义) 也可不写搜索内容
    tags = tag -n1 --list

    z = checkout
    zb = checkout -b
    zz = "!git checkout $(git base-branch)"
    zd = z dev
    zm = checkout master

    # 参数为修改后的branch名字
    branch-move = "!f(){ \
        new_branch=$1; \
        old_branch=$(git current-branch); \
        existed_in_remote=$(git ls-remote --heads origin $current_branch | head -n -1); \
        git branch --move $old_branch $new_branch; \
        if [ -n \"$existed_in_remote\" ]; then \
            git push origin :$old_branch $new_branch; \
        fi; \
        };f"
    bmv = "!git branch-move"

    # Delete all local branches that have been merged into the local master branch.
    branch-clean-local = "!git branch --merged | egrep -v \"(^\\*|master|dev|$(git base-branch))\" | xargs git branch -d"
    # Delete all remote branches that have been merged into the remote master branch.
    branch-clean-remote = "!git branch -r --merged | egrep -v \"(^\\*|master|dev|$(git base-branch))\" | sed 's/origin\\///' | xargs -n 1 git push origin --delete"

; }}}
; {{{ ### commit ###

    # commit with a message
    c = commit -a
    # 将新的修改全部应用到上次commit里
    cmd = "!git add --update && git commit --amend --no-edit"
    cme = "!git add --update && git commit --amend"
    ca = commit -a --message
    # commit and push
    cap = "!f() { git commit --all -m \"$@\" && git push; }; f"

; }}}
; {{{ ### checkout ###

    # checkout - update the working tree to match a branch or paths. [same as "o" for "out"]
    co = checkout
    cob = checkout -b
    co-rs = checkout --

; }}}
; {{{ ### cherry-pick ###

    # cherry-pick - apply the changes introduced by some existing commits; useful for moving small chunks of code between branches.
    pi = cherry-pick
    # cherry-pick - abort the picking process
    pia = cherry-pick --abort
    # cherry-pick - continue the picking process
    picc = cherry-pick --continue
    # cherry-pick without making a commit, and when when recording the commit, append a line that says "(cherry picked from commit ...)"
    pi-nx = cherry-pick --no-commit -x

; }}}
; {{{ ### clean ###
    dry = clean -d --dry-run  # 预览会clean什么
    # 默认只删除未追踪的文件,不包括ignore的文件，-d删除空目录 -x删除ignore的文件
    cl = clean -d -i
    clx = clean -d -x -i
    # Ignore all untracked files by appending them to .gitignore:
    ignore-untracked = "!git status | grep -P \"^\\t\" | grep -vF .gitignore | sed \"s/^\\t//\" >> .gitignore"

;}}}
; {{{ ### diff ###

    d = diff
    df = difftool
    dt-staged = difftool --staged
    # diff - show changes not yet staged
    dc = diff --cached
    # diff - show changes about to be commited
    ds = diff --staged
    # diff - show changes but by word, not line
    dw = diff --word-diff
    # diff deep - show changes with our preferred options. Also aliased as `diff-deep`.
    dd = diff --check --dirstat --find-copies --find-renames --histogram --color

; }}}
; {{{ ### grep ###

    rg = !rg $(git rev-parse --show-toplevel) --column --smart-case -e
    rg-ls = !rg $(git rev-parse --show-toplevel) --files
    rg-all = !rg $(git rev-parse --show-toplevel) --column --smart-case --no-ignore --hidden -g '!.git' -e
    rg-all-ls = !rg $(git rev-parse --show-toplevel) --no-ignore --hidden -g '!.git' --files

; }}}
; {{{ ### log ###

    # NOTE: log 加了--graph 会让使用nvim 作为log的 pager时出bug
    # log like - we like this summarization our key performance indicators. Also aliased as `log-like`.
    lg = "!git log -${1:-10} --all  --graph --topo-order --date=short --abbrev-commit --decorate --boundary --pretty=format:'%Cgreen%ad %Cred%h%Creset -%C(yellow)%d%Creset %s %Cblue[%cn]%Creset %Cblue%G?%Creset'; #"
    # 查看log，NOTE: 依赖Flog.vim插件
    ll = "!${EDITOR:-vi} --git-log"
    # log like long  - we like this summarization our key performance indicators. Also aliased as `log-like-long`.
    lll = log --graph --all --topo-order --date=iso8601-strict --no-abbrev-commit --abbrev=40 --decorate --boundary --pretty=format:'%Cgreen%ad %Cred%h%Creset -%C(yellow)%d%Creset %s %Cblue[%cn <%ce>]%Creset %Cblue%G?%Creset'

    ; }}}
; {{{ ### merge ###

    ; # merge but without autocommit, and with a commit even if the merge resolved as a fast-forward.
    ; mg = merge --no-commit --no-ff
    # merge but without autocommit, and with a commit 除非这个是同一路径上可以快进(faster-forward)的merge
    ; mg = merge --no-commit
    mg = merge
    mt = mergetool
    ; merge并删除被merge的分支
    mgd = "!git merge $1 && git branch -d $1; #"
    ; mgs = merge --squash
    ; merge squash 默认删除之前的分支，常用于开发feature分支
    mgs = "!git merge --squash $1 && git commit -a; #"
    ; 显示自共同父节点以来两条分支的提交
    merge-log = log --oneline --left-right HEAD...MERGE_HEAD
    ; 显示出现冲突的提交
    conflict-log = log --oneline --left-right --merge

; }}}
; {{{ ### rebase ###

    r = rebase
    ra = rebase --abort
    rc = "!git add --update && git rebase --continue"
    ri = rebase -i
    rir = "!git rebase -i origin/$(git current-branch)"
    # 选中n个commit进行rebase
    rin = "!git rebase -i HEAD~"$1"; #"
    # 直到某个hash的rebase
    rihs = "!git rebase -i "$1"; #"
    refix = checkout --conflict=diff3  # 对某个文件回到解决冲突前的状态

; }}}
; {{{ ### remote ###

    # 如果本地分支追踪的远程分支被删除，那么这个追踪会被删除，但是本地分支不会删除
    remote-prune-all = !git remote | xargs -n 1 git remote prune
    # remote - manage set of tracked repositories [same as "r"].
    ro = remote
    # remote show - gives some information about the remote <name>.
    ros = "!git remote show ${1:-origin}"

    remote-untrack = "!git branch --unset-upstream ${1:-$(git current-branch)}"
    # Push the current branch to the remote "origin", and set it to track the upstream branch
    publish = "!git push -u origin ${1:-$(git current-branch)}"
    # 删除远程分支(若不指定分支名就是当前分支的名字)
    unpublish = "!git push origin --delete ${1:-$(git current-branch)} && git branch --unset-upstream ${1:-$(git current-branch)}"
    # Fire up your difftool (e.g. Kaleidescope) with all the changes that
    # are on the current branch.
    code-review = "!git difftool origin/$(git current-branch)..."

; }}}
; {{{ ### revert ###

    # revert - undo the changes from some existing commits
    rv = revert
    # 撤销某次提交的修改，并且不自动提交，这样就可以干涉revert重做过程，手动进行提交
    rvn = revert --no-commit

; }}}
; {{{ ### stash ###

    sapply = "!git stash apply $1"
    # 保存对tracked文件的修改(包括未暂存和已暂存)
    # use case: 1. 切换分支前 2. 工作中突然想commit --amend 或者 fixup
    # 接受一个stash信息可选参数
    save = "!f() { \
        custom_message=$1; \
        WIP_message=WIP; \
        if [ -n \"$custom_message\" ]; then \
            WIP_message=\"$WIP_message: $custom_message\"; \
        fi; \
        git stash push -m \"$WIP_message - $(date '+%Y-%m-%d %H:%M:%S') - Base commit: $(git log -1 HEAD --pretty=format:'%h %s') \"; \
    };f"
    pop = stash pop
; {{{ snapshot 介绍

    # Stash snapshot - from http://blog.apiaxle.com/post/handy-git-tips-to-stop-you-getting-fired/
    # Take a snapshot of your current working tree without removing changes.
    # This is handy for refactoring where you can't quite fit what you've done
    # into a commit but daren't stray too far from now without a backup.
    #
    # Running this:
    #    $ git snapshot
    #
    # Creates this stash:
    #    stash@{0}: On feature/handy-git-tricks: snapshot: Mon Apr 8 12:39:06 BST 2013
    #
    # And seemingly no changes to your working tree.
; }}}
    snapshot = "!f() { \
        custom_message=$1; \
        Snapshot_message=Snapshot; \
        if [ -n \"$custom_message\" ]; then \
            Snapshot_message=\"$Snapshot_message $custom_message\"; \
        fi; \
        git save \"Snapshot $1\" && git stash apply 0 >/dev/null 2>&1; \
    };f"
    drop = stash drop
    sl = stash list
    ; 显示最近15次stash的哈希值 NOTE: 前提是stash注释里有WIP以便grep过滤
    ; 找到想要的stash后可以 git stash apply $stash_hash 或者 git branch recovered $stash_hash 恢复它
    stash-history = "!f() { \
        git fsck --unreachable | grep commit | cut -d\\  -f3 | xargs git log -15 --oneline --merges --no-walk --grep=WIP; \
    };f"
    sh = "!git stash-history"
    ; stash-pick =

; }}}
; {{{ ### submodule ###

    # submodule - enables foreign repositories to be embedded within a dedicated subdirectory of the source tree.
    sm = submodule
    smi = submodule init
    sma = submodule add
    sms = submodule sync
    smu = submodule update
    # submodule update with initialize
    smui = submodule update --init
    # submodule update with initialize and recursive; this is useful to bring a submodule fully up to date.
    smuir = submodule update --init --recursive

; }}}
; {{{ ### undo ###

    ; 只撤销了git commit操作，保留了 git add 操作。
    uncommit = reset --soft HEAD~1
    # 撤销commit， 清空工作区和暂存区
    # 命令末尾的#不能少
    uncommit-n = "!git reset --soft HEAD~$1; #"
    uncommit-h = reset --hard HEAD~1
    uncommit-hn = "!git reset --hard HEAD~$1; #"
    unadd = reset HEAD
    untrack = rm --cache --
    unstage = reset HEAD
    # Discard changes in a (list of) file(s) in working tree
    discard = checkout --

; }}}

; {{{ ### short alias ###

    ps = push
    ft = fetch
    pl = pull
    # 恢复一个删除的分支用 checkout -b <branch> <SHA>, 其中SHA可以从ref获取
    ref = reflog --no-abbrev

    # status with short format instead of full details
    s = status --short --branch

; }}}
; {{{ ### SHELL SCRIPTING ALIASES ###
    # 这些是用在其他alias里面的
    # Get the top level directory name
    top-name = rev-parse --show-toplevel
    # Get the current branch name
    current-branch = rev-parse --abbrev-ref HEAD
    # Get the upstream branch name
    upstream-name = !git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD)
    # Execute shell scripts. Git always runs scripts in the top directory.
    # For example "git exec pwd" will always show you the top directory.
    exec = ! exec
    # topic work flow 依赖的base branch
    base-branch = "!f(){ \
    git config --get gitalias.topic.base.branch.name || printf '%s\n' main; \
    };f"


; }}}
; {{{ ### other commands ###

    # initalize a repo and immediate add an empty commit, which makes rebase easier.
    init-empty = !"f() { git init && git commit --allow-empty --allow-empty-message --message ''; }; f"

    # ls-files - show information about files in the index and the working tree; like Unix "ls" command.
    ls = ls-files
    # ls-ignored -  list files that git has ignored.
    ls-ignored = ls-files --others --i --exclude-standard

    # 修改旧的commit      See https://blog.filippo.io/git-fixup-amending-an-older-commit/
    # NOTE: 如果和TARGET..HEAD 之间的commit有冲突，则会提交新的提交，否则只是改变原来提交的历史位置
    # usage:  git fixup <commit> [files...] 文件可选， commit可以用 :/abcd 来快速引用
    # GIT_EDITOR=true可以在没有冲突的时候跳过编辑过程
    fixup = "!f() { TARGET=$(git rev-parse \"$1\"); git commit --fixup=$TARGET && GIT_EDITOR=true git rebase --interactive --autosquash $TARGET~; }; f"

    # Expunge a file everywhere; this command is typically for a serious problem,
    # such as accidentally committing a file of sensitive data, such as passwords.
    # After you use command, you will likely need to force push everything.
    # See https://help.github.com/articles/removing-sensitive-data-from-a-repository/
    expunge = "!f() { git filter-branch --force --index-filter \"git rm --cached --ignore-unmatch $1\" --prune-empty --tag-name-filter cat -- --all }; f"


    # Delete a branch name, then create the same branch name based on master -
    # useful if you have, for example, a development branch and master branch
    # and they go out of sync, and you want to nuke the development branch.
    #
    # Calls the `publish` and `unpublish` aliases.
    #
    recreate = "!f() { [[ -n $@ ]] && git checkout \"$@\" && git unpublish && git checkout master && git branch -D \"$@\" && git checkout -b \"$@\" && git publish; }; f"

    # ahead of origin, Show commits that haven't made it to remote master yet.
    ahead = "!git log --oneline origin/$(git current-branch)..HEAD"
    # 最后一个commit
    last = log -1 HEAD
    ; Get everything new:
    get = !git pull --rebase && git submodule update --init --recursive
    # Push to all remotes
    push-to-all-remotes = !git remote | xargs -I% -n1 git push %
    # Show who contributed, in descending order by number of commits
    whorank = shortlog --summary --numbered --no-merges
    ; 获取hash全称，在遇到hash冲突的时候很有用
    abbr = "!sh -c 'git rev-list --all | grep ^$1 | while read commit; do git --no-pager log -n1 --pretty=format:\"%H %ci %an %s%n\" $commit; done' -"

; }}}

; {{{ ### unused ###

    df-staged = diff --staged --color
    df-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh diff
    ad-u = reset HEAD --
    ad-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh add
    co-rs-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh restore
    logs = log --oneline --decorate --graph --pretty=format:\"(%h)  %an, %ar: %s\"
    logs-all = log --oneline --decorate --graph --all --pretty=format:\"(%h)  %an, %ar: %s\"
    log-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh log
    ig-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh ignore
    ; edit = !nvim `git ls-files -m --other --exclude-standard` -p

; }}}
