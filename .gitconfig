;基础设置 {{{
# 专为github设置的代理
[http "https://github.com"]
    proxy = socks5://127.0.0.1:6543
[https "https://github.com"]
    proxy = socks5://127.0.0.1:6543
[user]
    name = alex
    email = 419725794@qq.com
[core]
    editor = nvim
    quotepath = false  # 解决git ls不显示中文的问题

[commit]
    # 设置 commit 模板文件路径
    template = ~/.config/git/.gitmessage
[pager]
    # 以下命令不使用$PAGER浏览
    log = false
    branch = false
    tag = false
    reflog = false
    diff = false
    shortlog = false

# difftool用editor(nvr) 有bug， 还是nvim 好
[diff]
    tool = vimdiff3
[difftool]
    prompt = false
    trustExitCode = true
[difftool "vimdiff3"]
    path = nvim

[merge]
    tool = vim_mergetool
    conflictStyle = diff3
[mergetool]
    prompt = false
    trustExitCode = true
    # 这样在解决冲突后就不会保留.orig文件了
    keepBackup = false
[mergetool "vim_mergetool"]
    # floaterm用nvr mergetool 有bug 还是nvim好, 然后<Alt-o>放大floaterm
    cmd = nvim -f -c "MergetoolStart" "$MERGED" "$BASE" "$LOCAL" "$REMOTE"

[pull]
    # pull时用rebase="interactive"替代merge
    ; rebase = "interactive"
    rebase = true

[push]
    # push自动带上tags
    followTags = true

[credential]
    # 缓存HTTP/HTTPS方式输入的用户名密码时间, 设置为
    # 时间单位为秒 此处为大于100年
    helper = cache --timeout=3600000000

# 用于 topic 工作流的自定义变量，定义主要用于向远程仓库推送的分支
[gitalias "topic.base.branch"]
	name = master

; }}}

[alias]    # 很多alias来自 https://github.com/GitAlias/gitalias/blob/master/gitalias.txt

; {{{ ### work flow ###

    ; 编辑和暂存有冲突的文件
    ; NOTE: 工作流:
    ;             $ git edit-unmerged
    ;                 ... edit ...
    ;                 ... test ...
    ;             $ git add-unmerged
    ;             $ git commit  # or git rebase --continue or whatever
    edit-unmerged = "!f() { git diff --name-status --diff-filter=U | cut -f2 ; }; ${EDITOR:-vi} `f`"
    add-unmerged = "!f() { git diff --name-status --diff-filter=U | cut -f2 ; }; git add `f`"

    # 预存提交信息
    todo = !${EDITOR:-vi} $(git rev-parse --git-dir)/.template
    # 用预存在文件里的信息提交
    cm = !git commit -F $(git rev-parse --git-dir)/.template

; {{{ ======== topic 工作流 =========
    ; 参考 https://github.com/GitAlias/gitalias/blob/master/gitalias.txt#L1217
    set-global-base-branch = config --global gitalias.topic.base.branch.name
    set-local-base-branch = config --local gitalias.topic.base.branch.name
    ; global base-branch 默认是master， 这里设置local base-branch
    set-bb = "!git set-local-base-branch"
    bb = "!git base-branch"


; {{{ topic-start-remote 介绍
    ##
    # Start a topic branch.
    #
    # Example:
    #
    #     git topic-start add-feature-foo
    #
    # We use this alias to begin work on a new feature,
    # new task, new fix, new refactor, new optimization, etc.
    #
    # Customize this alias as you like for your own workflow.
    #
    # Our workflow does these steps:
    #
    #   1. Update the base branch.
    #   2. Create a new branch with your topic name, based on the base branch.
    #   3. Push the topic branch, so our team members can see the new branch.
    #
    # If you use a sharing site such a GitHub, and use typical settings,
    # then this implementation makes your branch visible to collaborators.
    #
    # Many teams share branches before they are fully ready, to help
    # the team provide feedback on the work-in-progress, and also to
    # run any automatic tests to verify the branch runs successfully.
    ##

; }}}
    ; 开始一个topic分支并推送到remote
    topic-start-remote = "!git topic-start-local $1 && git push -u origin $1; #"
    ; 只在本地开启一个topic
    topic-start-local = "!f(){ \
        topic_branch=$1; \
        base_branch=$(git base-branch); \
        git checkout $base_branch;  \
        git pull; \
        git checkout -b $topic_branch $base_branch; \
        };f"
    tstr = "!git topic-start-remote"
    tst = "!git topic-start-local"

; {{{ topic-stop-remote 介绍
    ##
    # We use this alias to complete work on a new feature,
    # new task, new fix, new refactor, new optimization, etc.
    #
    # Our workflow does these steps:
    #   1. Delete the topic branch locally.
    #   2. Delete the topic branch remotely.
    #
    # If you use a sharing site such a GitHub, and use typical settings,
    # then this implementation deletes your branch for the site.
    #
    # Many teams choose to delete topic branches when they are finished,
    # to keep the repositories clean and with a smaller number of branches.
    #
    # If git says "unable to push to unqualified destination" then it means
    # that the remote branch doesn't exist, so git is unable to delete it.
    # That's fine; it means someone else has already deleted the branch.
    ##

; }}}
    topic-stop-remote = "!f(){ \
        topic_branch=${1:-$(git current-branch)}; \
        base_branch=$(git base-branch); \
        current_branch = $(git current-branch); \
        if [[ $topic_branch = $base_branch ]]; then \
            printf \"You are asking to do git topic-stop,\n\"; \
            printf \"but you can't stop the base branch: $base_branch.\n\"; \
            printf \"Please ask to stop valid topic branch.\n\"; \
        elif [[ $topic_branch = master ]]; then \
            printf \"You can't stop the master branch.\n\"; \
        else \
            if [[ current_branch != $base_branch ]]; then \
                git checkout $base_branch; \
            fi; \
            git branch --delete $topic_branch; \
            git push origin --delete $topic_branch; \
            git remote-prune-all;  \
        fi; \
        };f"

    topic-stop-local = "!f(){ \
        topic_branch=${1:-$(git current-branch)}; \
        base_branch=$(git base-branch); \
        current_branch = $(git current-branch); \
        if [[ $topic_branch = $base_branch ]]; then \
            printf \"You are asking to do git topic-stop,\n\"; \
            printf \"but you can't stop the base branch: $base_branch.\n\"; \
            printf \"Please ask to stop valid topic branch.\n\"; \
        elif [[ $topic_branch = master ]]; then \
            printf \"You can't stop the master branch.\n\"; \
        else \
            if [[ current_branch != $base_branch ]]; then \
                git checkout $base_branch; \
            fi; \
            git branch --delete \"$topic_branch\"; \
        fi; \
        };f"
    tspr = "!git topic-stop-remote"
    tsp = "!git topic-stop-local"


; {{{ sync介绍
    ##
    # Update the current topic branch by synchronizing changes.
    #
    # If you use any kind of testing framework, or test driven development,
    # then it can be wise to test your topic immediately after running this,
    # to ensure that any available updates are successfully integrated.
    ##
; }}}
    sync = "!f(){ \
        target_branch=${1:-$(git current-branch)}; \
        current_branch = $(git current-branch); \
        if [[ $current_branch != $topic_branch ]]; then \
            git checkout $target_branch; \
        fi; \
        git pull && git push; \
        };f"
    sn = "!git sync"

    # 参数为修改后的branch名字
    topic-move-remote = "!f(){ \
        new_branch=$1; \
        old_branch=$(git current-branch); \
        git branch --move $old_branch $new_branch; \
        git push origin :$old_branch $new_branch; \
        };f"
    topic-move-local = "!f(){ \
        new_branch=$1; \
        old_branch=$(git current-branch); \
        git branch --move $old_branch $new_branch; \
        };f"
    tmvr = "!git topic-move-remote"
    tmv = "!git topic-move-local"

; }}}

; }}}

; {{{ ### add ###

    a = add
    # add all
    aa = add -A
    # add by patch - looks at each change, and asks if we want to put it in the repo.
    ap = add --patch
    # add just the files that are updated.
    au = add --update

; }}}
; {{{ ### branch ###

    b = branch
    # 显示分支列表并 untrack 被删除的remote分支
    bl = "!git branch -av; git remote-prune-all &"
    bm = branch --merged
    bnm = branch --no-merged
    bd = branch -d
    bD = branch -D  # 强制删除未merge的分支
    # 可在--list 后面写搜索版本号, 比如git tgs '*1' (如果不加引号要用\*转义) 也可不写搜索内容
    tags = tag -n1 --list

    z = checkout
    zb = checkout -b
    zz = "!git checkout $(git base-branch)"
    zd = z dev
    zm = checkout master

; }}}
; {{{ ### commit ###

    # commit with a message
    c = commit -a
    # 将新的修改全部应用到上次commit里
    cmd = "!git add --update && git commit --amend --no-edit"
    cme = "!git add --update && git commit --amend"
    ca = commit -a --message
    # commit and push
    cap = "!f() { git commit --all -m \"$@\" && git push; }; f"

; }}}
; {{{ ### checkout ###

    # checkout - update the working tree to match a branch or paths. [same as "o" for "out"]
    co = checkout
    cob = checkout -b
    co-rs = checkout --

; }}}
; {{{ ### cherry-pick ###

    # cherry-pick - apply the changes introduced by some existing commits; useful for moving small chunks of code between branches.
    cp = cherry-pick
    # cherry-pick - abort the picking process
    cpa = cherry-pick --abort
    # cherry-pick - continue the picking process
    cpc = cherry-pick --continue
    # cherry-pick without making a commit, and when when recording the commit, append a line that says "(cherry picked from commit ...)"
    cp-nx = cherry-pick --no-commit -x

; }}}
; {{{ ### diff ###

    d = diff
    df = difftool
    dt-staged = difftool --staged
    # diff - show changes not yet staged
    dc = diff --cached
    # diff - show changes about to be commited
    ds = diff --staged
    # diff - show changes but by word, not line
    dw = diff --word-diff
    # diff deep - show changes with our preferred options. Also aliased as `diff-deep`.
    dd = diff --check --dirstat --find-copies --find-renames --histogram --color

; }}}
; {{{ ### grep ###

    # grep group - search with our preferred options. Also aliased as `grep-group`.
    gr = grep --break --heading --line-number --color
    rg = !rg $(git rev-parse --show-toplevel) --column --smart-case -e
    rg-ls = !rg $(git rev-parse --show-toplevel) --files
    rg-all = !rg $(git rev-parse --show-toplevel) --column --smart-case --no-ignore --hidden -g '!.git' -e
    rg-all-ls = !rg $(git rev-parse --show-toplevel) --no-ignore --hidden -g '!.git' --files

; }}}
; {{{ ### log ###

    # NOTE: log 加了--graph 会让使用nvim 作为log的 pager时出bug
    # log like - we like this summarization our key performance indicators. Also aliased as `log-like`.
    lg = log -10 --graph --topo-order --date=short --abbrev-commit --decorate --all --boundary --pretty=format:'%Cgreen%ad %Cred%h%Creset -%C(yellow)%d%Creset %s %Cblue[%cn]%Creset %Cblue%G?%Creset'
    # 自定义log行数
    lgn = "!git log -$1 --graph --topo-order --date=short --abbrev-commit --decorate --all --boundary --pretty=format:'%Cgreen%ad %Cred%h%Creset -%C(yellow)%d%Creset %s %Cblue[%cn]%Creset %Cblue%G?%Creset'; #"
    # 查看log，NOTE: 依赖Flog.vim插件
    ll = "!${EDITOR:-vi} --git-log"
    # log like long  - we like this summarization our key performance indicators. Also aliased as `log-like-long`.
    lll = log --graph --topo-order --date=iso8601-strict --no-abbrev-commit --abbrev=40 --decorate --all --boundary --pretty=format:'%Cgreen%ad %Cred%h%Creset -%C(yellow)%d%Creset %s %Cblue[%cn <%ce>]%Creset %Cblue%G?%Creset'

    ; }}}
; {{{ ### merge ###

    ; # merge but without autocommit, and with a commit even if the merge resolved as a fast-forward.
    ; mg = merge --no-commit --no-ff
    # merge but without autocommit, and with a commit 除非这个是同一路径上可以快进(faster-forward)的merge
    ; mg = merge --no-commit
    mg = merge
    mt = mergetool
    # merge并删除被merge的分支
    mgd = "!git merge $1 && git branch -d $1; #"
    ; mgs = merge --squash
    ; merge squash 默认删除之前的分支，常用于开发feature分支
    mgs = "!git merge --squash $1 && git commit -a; #"

; }}}
; {{{ ### rebase ###

    r = rebase
    ra = rebase --abort
    rc = "!git add --update && git rebase --continue"
    ri = rebase -i
    # NOTE: 可以改成maser或dev
    rir = rebase -i origin/master
    # 选中n个commit进行rebase
    rin = "!git rebase -i HEAD~"$1"; #"
    # 直到某个hash的rebase
    rihs = "!git rebase -i "$1"; #"
    refix = checkout --conflict=diff3  # 对某个文件回到解决冲突前的状态

; }}}
; {{{ ### remote ###

    # 如果本地分支追踪的远程分支被删除，那么这个追踪会被删除，但是本地分支不会删除
    remote-prune-all = !git remote | xargs -n 1 git remote prune
    # remote - manage set of tracked repositories [same as "r"].
    ro = remote
    # remote show - gives some information about the remote <name>.
    ros = "!git remote show ${1:-origin}"

    remote-untrack = "!git branch --unset-upstream ${1:-$(git current-branch)}"
    # Push the current branch to the remote "origin", and set it to track the upstream branch
    publish = "!git push -u origin ${1:-$(git current-branch)}"
    # 删除远程分支(若不指定分支名就是当前分支的名字)
    unpublish = "!git push origin --delete ${1:-$(git current-branch)}"
    # Fire up your difftool (e.g. Kaleidescope) with all the changes that
    # are on the current branch.
    code-review = "!git difftool origin/$(git current-branch)..."

; }}}
; {{{ ### revert ###

    # revert - undo the changes from some existing commits
    rv = revert
    # 撤销某次提交的修改，并且不自动提交，这样就可以干涉revert重做过程，手动进行提交
    rvn = revert --no-commit

; }}}
; {{{ ### stash ###

    sapply = "!git stash apply stash@{$1}"
    # 保存对tracked文件的修改(包括未暂存和已暂存)
    save = "!git stash push -m \"$(git log -1 HEAD --pretty=format:'%h - %s') - $(date '+%Y-%m-%d %H:%M:%S %A') - WIP\""
    pop = stash pop
; {{{ snapshot 介绍

    # Stash snapshot - from http://blog.apiaxle.com/post/handy-git-tips-to-stop-you-getting-fired/
    # Take a snapshot of your current working tree without removing changes.
    # This is handy for refactoring where you can't quite fit what you've done
    # into a commit but daren't stray too far from now without a backup.
    #
    # Running this:
    #    $ git snapshot
    #
    # Creates this stash:
    #    stash@{0}: On feature/handy-git-tricks: snapshot: Mon Apr 8 12:39:06 BST 2013
    #
    # And seemingly no changes to your working tree.
; }}}
    snapshot = "!git save && git stash apply stash@{0} >/dev/null 2>&1"
    stashes = stash list
    sl = stash list

; }}}
; {{{ ### submodule ###

    # submodule - enables foreign repositories to be embedded within a dedicated subdirectory of the source tree.
    sm = submodule
    smi = submodule init
    sma = submodule add
    sms = submodule sync
    smu = submodule update
    # submodule update with initialize
    smui = submodule update --init
    # submodule update with initialize and recursive; this is useful to bring a submodule fully up to date.
    smuir = submodule update --init --recursive

; }}}
; {{{ ### undo ###

    ; 只撤销了git commit操作，保留了 git add 操作。
    uncommit = reset --soft HEAD~1
    # 撤销commit， 清空工作区和暂存区
    # 命令末尾的#不能少
    uncommit-n = "!git reset --soft HEAD~$1; #"
    uncommit-h = reset --hard HEAD~1
    uncommit-hn = "!git reset --hard HEAD~$1; #"
    unadd = reset HEAD
    untracke = rm --cache --
    unstage = reset HEAD
    # Discard changes in a (list of) file(s) in working tree
    discard = checkout --

; }}}

; {{{ ### short alias ###

    ps = push
    ft = fetch
    pl = pull
    # 恢复一个删除的分支用 checkout -b <branch> <SHA>, 其中SHA可以从ref获取
    ref = reflog --no-abbrev

    # status with short format instead of full details
    s = status --short --branch

; }}}
; {{{ ### SHELL SCRIPTING ALIASES ###
    # 这些是用在其他alias里面的
    # Get the top level directory name
    top-name = rev-parse --show-toplevel
    # Get the current branch name
    current-branch = rev-parse --abbrev-ref HEAD
    # Get the upstream branch name
    upstream-name = !git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD)
    # Execute shell scripts. Git always runs scripts in the top directory.
    # For example "git exec pwd" will always show you the top directory.
    exec = ! exec
    # topic work flow 依赖的base branch
    base-branch = "!f(){ \
    git config --get gitalias.topic.base.branch.name || printf '%s\n' main; \
    };f"


; }}}
; {{{ ### other commands ###

    # initalize a repo and immediate add an empty commit, which makes rebase easier.
    init-empty = !"f() { git init && git commit --allow-empty --allow-empty-message --message ''; }; f"

    # ls-files - show information about files in the index and the working tree; like Unix "ls" command.
    ls = ls-files
    # ls-ignored -  list files that git has ignored.
    ls-ignored = ls-files --others --i --exclude-standard

    # 修改旧的commit      See https://blog.filippo.io/git-fixup-amending-an-older-commit/
    fixup = "!f() { TARGET=$(git rev-parse \"$1\"); git commit --fixup=$TARGET && GIT_EDITOR=true git rebase --interactive --autosquash $TARGET~; }; f"

    # Ignore all untracked files by appending them to .gitignore:
    ignore-untracked = "!git status | grep -P \"^\\t\" | grep -vF .gitignore | sed \"s/^\\t//\" >> .gitignore"
    # Expunge a file everywhere; this command is typically for a serious problem,
    # such as accidentally committing a file of sensitive data, such as passwords.
    # After you use command, you will likely need to force push everything.
    # See https://help.github.com/articles/removing-sensitive-data-from-a-repository/
    expunge = "!f() { git filter-branch --force --index-filter \"git rm --cached --ignore-unmatch $1\" --prune-empty --tag-name-filter cat -- --all }; f"

    # Delete all branches that have already been merged into the master branch.
    master-branch-clean = "!git master-branch-clean-local"
    # Delete all local branches that have been merged into the local master branch.
    master-branch-clean-local = "!git checkout master && git branch --merged | xargs git branch --delete"
    # Delete all remote branches that have been merged into the remote master branch.
    master-branch-clean-remote = "!git branch --remotes --merged origin/master | sed 's# *origin/##' | grep -v '^master$' xargs -I% git push origin :% 2>&1 | grep --colour=never 'deleted'"

    # Delete a branch name, then create the same branch name based on master -
    # useful if you have, for example, a development branch and master branch
    # and they go out of sync, and you want to nuke the development branch.
    #
    # Calls the `publish` and `unpublish` aliases.
    #
    recreate = "!f() { [[ -n $@ ]] && git checkout \"$@\" && git unpublish && git checkout master && git branch -D \"$@\" && git checkout -b \"$@\" && git publish; }; f"

    # ahead of origin, Show commits that haven't made it to remote master yet.
    ahead = "!git log --oneline origin/$(git current-branch)..HEAD"
    # 最后一个commit
    last = log -1 HEAD
    ; Get everything new:
    get = !git pull --rebase && git submodule update --init --recursive
    # Push to all remotes
    push-to-all-remotes = !git remote | xargs -I% -n1 git push %
    # Show who contributed, in descending order by number of commits
    whorank = shortlog --summary --numbered --no-merges
    ; 获取hash全称，在遇到hash冲突的时候很有用
    abbr = "!sh -c 'git rev-list --all | grep ^$1 | while read commit; do git --no-pager log -n1 --pretty=format:\"%H %ci %an %s%n\" $commit; done' -"

; }}}

; {{{ ### unused ###

    df-staged = diff --staged --color
    df-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh diff
    ad-u = reset HEAD --
    ad-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh add
    co-rs-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh restore
    logs = log --oneline --decorate --graph --pretty=format:\"(%h)  %an, %ar: %s\"
    logs-all = log --oneline --decorate --graph --all --pretty=format:\"(%h)  %an, %ar: %s\"
    log-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh log
    ig-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh ignore
    ; edit = !nvim `git ls-files -m --other --exclude-standard` -p

; }}}
