;基础设置 {{{
# 专为github设置的代理
[http "https://github.com"]
    proxy = socks5://127.0.0.1:6543
[https "https://github.com"]
    proxy = socks5://127.0.0.1:6543
[user]
    name = alex
    email = 419725794@qq.com
[core]
    editor = nvim
    quotepath = false  # 解决git ls不显示中文的问题

[commit]
    # 设置 commit 模板文件路径
    template = ~/.config/git/.gitmessage
[pager]
    # 以下命令不使用$PAGER浏览
    log = false
    branch = false
    tag = false
    reflog = false
    diff = false
    shortlog = false

# difftool用editor(nvr) 有bug， 还是nvim 好
[diff]
    tool = vimdiff3
[difftool]
    prompt = false
    trustExitCode = true
[difftool "vimdiff3"]
    path = nvim

[merge]
    tool = vim_mergetool
    conflictStyle = diff3
[mergetool]
    prompt = false
    trustExitCode = true
    # 这样在解决冲突后就不会保留.orig文件了
    keepBackup = false
[mergetool "vim_mergetool"]
    # floaterm用nvr mergetool 有bug 还是nvim好, 然后<Alt-o>放大floaterm
    cmd = nvim -f -c "MergetoolStart" "$MERGED" "$BASE" "$LOCAL" "$REMOTE"

[pull]
    # pull时用rebase="interactive"替代merge
    ; rebase = "interactive"
    rebase = true

[push]
    # push自动带上tags
    followTags = true

[credential]
    # 缓存HTTP/HTTPS方式输入的用户名密码时间, 设置为
    # 时间单位为秒 此处为大于100年
    helper = cache --timeout=3600000000
; }}}

[alias]    # 很多alias来自 https://github.com/GitAlias/gitalias/blob/master/gitalias.txt

; {{{ ### work flow ###

    ; 编辑和暂存有冲突的文件
    ; NOTE: 工作流:
    ;             $ git edit-unmerged
    ;                 ... edit ...
    ;                 ... test ...
    ;             $ git add-unmerged
    ;             $ git commit  # or git rebase --continue or whatever
    edit-unmerged = "!f() { git diff --name-status --diff-filter=U | cut -f2 ; }; ${EDITOR:-vi} `f`"
    add-unmerged = "!f() { git diff --name-status --diff-filter=U | cut -f2 ; }; git add `f`"

    # 预存提交信息
    todo = !${EDITOR:-vi} $(git rev-parse --git-dir)/.template
    # 用预存在文件里的信息提交
    cm = !git commit -F $(git rev-parse --git-dir)/.template

; }}}

; {{{ ### add ###

    a = add
    # add all
    aa = add -A
    # add by patch - looks at each change, and asks if we want to put it in the repo.
    ap = add --patch
    # add just the files that are updated.
    au = add --update

; }}}
; {{{ ### branch ###

    b = branch
    bl = branch -av  # 显示分支列表
    bm = branch --merged
    bnm = branch --no-merged
    bd = branch -d
    bD = branch -D  # 强制删除未merge的分支
    # 可在--list 后面写搜索版本号, 比如git tgs '*1' (如果不加引号要用\*转义) 也可不写搜索内容
    tags = tag -n1 --list
    stashes = stash list

    # 快速切换或者创建新分支
    z = checkout -B
    zd = checkout -B dev
    zm = checkout master

; }}}
; {{{ ### commit ###

    # commit with a message
    c = commit -a
    # 将新的修改全部应用到上次commit里
    cmd = "!git add --update && git commit --amend --no-edit"
    cme = "!git add --update && git commit --amend"
    ca = commit -a --message
    # commit and push
    cap = "!f() { git commit --all -m \"$@\" && git push; }; f"

; }}}
; {{{ ### checkout ###

    # checkout - update the working tree to match a branch or paths. [same as "o" for "out"]
    co = checkout
    cob = checkout -b
    co-rs = checkout --

; }}}
; {{{ ### cherry-pick ###

    # cherry-pick - apply the changes introduced by some existing commits; useful for moving small chunks of code between branches.
    cp = cherry-pick
    # cherry-pick - abort the picking process
    cpa = cherry-pick --abort
    # cherry-pick - continue the picking process
    cpc = cherry-pick --continue
    # cherry-pick without making a commit, and when when recording the commit, append a line that says "(cherry picked from commit ...)"
    cp-nx = cherry-pick --no-commit -x

; }}}
; {{{ ### diff ###

    d = diff
    df = difftool
    dt-staged = difftool --staged
    # diff - show changes not yet staged
    dc = diff --cached
    # diff - show changes about to be commited
    ds = diff --staged
    # diff - show changes but by word, not line
    dw = diff --word-diff
    # diff deep - show changes with our preferred options. Also aliased as `diff-deep`.
    dd = diff --check --dirstat --find-copies --find-renames --histogram --color

; }}}
; {{{ ### grep ###

    # grep group - search with our preferred options. Also aliased as `grep-group`.
    gr = grep --break --heading --line-number --color
    rg = !rg $(git rev-parse --show-toplevel) --column --smart-case -e
    rg-ls = !rg $(git rev-parse --show-toplevel) --files
    rg-all = !rg $(git rev-parse --show-toplevel) --column --smart-case --no-ignore --hidden -g '!.git' -e
    rg-all-ls = !rg $(git rev-parse --show-toplevel) --no-ignore --hidden -g '!.git' --files

; }}}
; {{{ ### log ###

    # NOTE: log 加了--graph 会让使用nvim 作为log的 pager时出bug
    # log like - we like this summarization our key performance indicators. Also aliased as `log-like`.
    lg = log -10 --graph --topo-order --date=short --abbrev-commit --decorate --all --boundary --pretty=format:'%Cgreen%ad %Cred%h%Creset -%C(yellow)%d%Creset %s %Cblue[%cn]%Creset %Cblue%G?%Creset'
    # 自定义log行数
    lgn = "!git log -$1 --graph --topo-order --date=short --abbrev-commit --decorate --all --boundary --pretty=format:'%Cgreen%ad %Cred%h%Creset -%C(yellow)%d%Creset %s %Cblue[%cn]%Creset %Cblue%G?%Creset'; #"
    # 查看log，NOTE: 依赖Flog.vim插件
    ll = "!${EDITOR:-vi} --git-log"
    # log like long  - we like this summarization our key performance indicators. Also aliased as `log-like-long`.
    lll = log --graph --topo-order --date=iso8601-strict --no-abbrev-commit --abbrev=40 --decorate --all --boundary --pretty=format:'%Cgreen%ad %Cred%h%Creset -%C(yellow)%d%Creset %s %Cblue[%cn <%ce>]%Creset %Cblue%G?%Creset'

    ; }}}
; {{{ ### merge ###

    ; # merge but without autocommit, and with a commit even if the merge resolved as a fast-forward.
    ; mg = merge --no-commit --no-ff
    # merge but without autocommit, and with a commit 除非这个是同一路径上可以快进(faster-forward)的merge
    ; mg = merge --no-commit
    mg = merge
    mt = mergetool
    # merge并删除被merge的分支
    mgd = "!git merge $1 && git branch -d $1; #"
    ; mgs = merge --squash
    ; merge squash 默认删除之前的分支，常用于开发feature分支
    mgs = "!git merge --squash $1 && git commit -a; #"

; }}}
; {{{ ### rebase ###

    r = rebase
    ra = rebase --abort
    rc = "!git add --update && git rebase --continue"
    ri = rebase -i
    # NOTE: 可以改成maser或dev
    rir = rebase -i origin/master
    # 选中n个commit进行rebase
    rin = "!git rebase -i HEAD~"$1"; #"
    # 直到某个hash的rebase
    rihs = "!git rebase -i "$1"; #"
    refix = checkout --conflict=diff3  # 对某个文件回到解决冲突前的状态

; }}}
; {{{ ### remote ###

    # 如果本地分支追踪的远程分支被删除，那么这个追踪会被删除，但是本地分支不会删除
    remote-prune-all = !git remote | xargs -n 1 git remote prune
    # 删除远程分支origin (origin可以换成别的)
    remote-delete-branch = push origin --delete
    # remote - manage set of tracked repositories [same as "r"].
    ro = remote
    # remote show - gives some information about the remote <name>.
    ros = remote show

    # Push the current branch to the remote "origin", and set it to track
    # the upstream branch
    publish = "!git push -u origin $(git branch-name)"
    # Delete the remote version of the current branch
    unpublish = "!git push origin :"
    # Fire up your difftool (e.g. Kaleidescope) with all the changes that
    # are on the current branch.
    code-review = "!git difftool origin/$(git branch-name)..."

; }}}
; {{{ ### revert ###

    # revert - undo the changes from some existing commits
    rv = revert
    # revert without autocommit; useful when you're reverting more than one commits' effect to your index in a row.
    rvnc = revert --no-commit

; }}}
; {{{ ### stash ###

    save = stash push
    pop = stash pop
; {{{ snapshot 介绍

    # Stash snapshot - from http://blog.apiaxle.com/post/handy-git-tips-to-stop-you-getting-fired/
    # Take a snapshot of your current working tree without removing changes.
    # This is handy for refactoring where you can't quite fit what you've done
    # into a commit but daren't stray too far from now without a backup.
    #
    # Running this:
    #    $ git snapshot
    #
    # Creates this stash:
    #    stash@{0}: On feature/handy-git-tricks: snapshot: Mon Apr 8 12:39:06 BST 2013
    #
    # And seemingly no changes to your working tree.
; }}}
    snapshot = !git stash push "snapshot: $(date)" && git stash apply "stash@{0}"

; }}}
; {{{ ### submodule ###

    # submodule - enables foreign repositories to be embedded within a dedicated subdirectory of the source tree.
    sm = submodule
    smi = submodule init
    sma = submodule add
    sms = submodule sync
    smu = submodule update
    # submodule update with initialize
    smui = submodule update --init
    # submodule update with initialize and recursive; this is useful to bring a submodule fully up to date.
    smuir = submodule update --init --recursive

; }}}
; {{{ ### undo ###

    uncommit = reset --soft HEAD~1
    # 命令末尾的#不能少
    uncommit-n = "!git reset --soft HEAD~$1; #"
    uncommit-h = reset --hard HEAD~1
    uncommit-hn = "!git reset --hard HEAD~$1; #"
    unadd = reset HEAD
    untracke = rm --cache --
    unstage = reset HEAD
    # Discard changes in a (list of) file(s) in working tree
    discard = checkout --

; }}}

; {{{ ### short alias ###

    ps = push
    ft = fetch
    pl = pull
    # 恢复一个删除的分支用 checkout -b <branch> <SHA>, 其中SHA可以从ref获取
    ref = reflog --no-abbrev

    # status with short format instead of full details
    s = status --short --branch

; }}}
; {{{ ### other commands ###

    # initalize a repo and immediate add an empty commit, which makes rebase easier.
    init-empty = !"f() { git init && git commit --allow-empty --allow-empty-message --message ''; }; f"

    # ls-files - show information about files in the index and the working tree; like Unix "ls" command.
    ls = ls-files
    # ls-ignored -  list files that git has ignored.
    ls-ignored = ls-files --others --i --exclude-standard

    # 修改旧的commit      See https://blog.filippo.io/git-fixup-amending-an-older-commit/
    fixup = "!f() { TARGET=$(git rev-parse \"$1\"); git commit --fixup=$TARGET && GIT_EDITOR=true git rebase --interactive --autosquash $TARGET~; }; f"

    # Ignore all untracked files by appending them to .gitignore:
    ignore-untracked = "!git status | grep -P \"^\\t\" | grep -vF .gitignore | sed \"s/^\\t//\" >> .gitignore"
    # Expunge a file everywhere; this command is typically for a serious problem,
    # such as accidentally committing a file of sensitive data, such as passwords.
    # After you use command, you will likely need to force push everything.
    # See https://help.github.com/articles/removing-sensitive-data-from-a-repository/
    expunge = "!f() { git filter-branch --force --index-filter \"git rm --cached --ignore-unmatch $1\" --prune-empty --tag-name-filter cat -- --all }; f"

    # Delete all branches that have already been merged into the master branch.
    master-branch-clean = "!git master-branch-clean-local"
    # Delete all local branches that have been merged into the local master branch.
    master-branch-clean-local = "!git checkout master && git branch --merged | xargs git branch --delete"
    # Delete all remote branches that have been merged into the remote master branch.
    master-branch-clean-remote = "!git branch --remotes --merged origin/master | sed 's# *origin/##' | grep -v '^master$' xargs -I% git push origin :% 2>&1 | grep --colour=never 'deleted'"
    # 获取当前branch名字，主要用在其他alias里
    branch-name = "!git rev-parse --abbrev-ref HEAD"
    # Delete a branch name, then create the same branch name based on master -
    # useful if you have, for example, a development branch and master branch
    # and they go out of sync, and you want to nuke the development branch.
    #
    # Calls the `publish` and `unpublish` aliases.
    #
    recreate = "!f() { [[ -n $@ ]] && git checkout \"$@\" && git unpublish && git checkout master && git branch -D \"$@\" && git checkout -b \"$@\" && git publish; }; f"

    # ahead of origin, Show commits that haven't made it to remote master yet.
    ahead = "!git log --oneline origin/$(git branch-name)..HEAD"
    # 最后一个commit
    last = log -1 HEAD
    ; Get everything new:
    get = !git pull --rebase && git submodule update --init --recursive
    # Push to all remotes
    push-to-all-remotes = !git remote | xargs -I% -n1 git push %
    # Show who contributed, in descending order by number of commits
    whorank = shortlog --summary --numbered --no-merges
    ; 获取hash全称，在遇到hash冲突的时候很有用
    abbr = "!sh -c 'git rev-list --all | grep ^$1 | while read commit; do git --no-pager log -n1 --pretty=format:\"%H %ci %an %s%n\" $commit; done' -"

; }}}

; {{{ ### unused ###

    df-staged = diff --staged --color
    df-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh diff
    ad-u = reset HEAD --
    ad-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh add
    co-rs-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh restore
    logs = log --oneline --decorate --graph --pretty=format:\"(%h)  %an, %ar: %s\"
    logs-all = log --oneline --decorate --graph --all --pretty=format:\"(%h)  %an, %ar: %s\"
    log-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh log
    ig-fzf = !zsh $HOME/repo/scripts/func/forgit.zsh ignore
    ; edit = !nvim `git ls-files -m --other --exclude-standard` -p

; }}}
